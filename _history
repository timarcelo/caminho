{"entries":[{"timestamp":1737228418312,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n"],[0,"</xm"]],"start1":12,"start2":12,"length1":70,"length2":113}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"/*\n*Robô Seguidor de linha By Marcelo Ricardo Sestrem\n*/\nenum Leds {\n    ON = 1,\n    OFF = 2\n}\nenum Sensor {\n    Esquerdo = 1,\n    Centro = 2,\n    Direito = 3\n}\nenum Um_sensor {\n    //% block=\"▮\"\n    branco = 1,\n    //% block=\"▯\"\n    preto = 2\n}\nenum Dois_sensores {\n    //% block=\"▮▮\"\n    branco_branco = 1,\n    //% block=\"▮▯\"\n    branco_preto = 2,\n    //% block=\"▯▮\"\n    preto_branco = 3,\n    //% block=\"▯▯\"\n    preto_preto = 4\n}\n\nenum Tres_sensores {\n    //% block=\"▮▮▮\"\n    branco_branco_branco = 1,\n    //% block=\"▮▯▮\"\n    branco_preto_branco = 2,\n    //% block=\"▯▮▮\"\n    preto_branco_branco = 3,\n    //% block=\"▯▯▮\"\n    branco_branco_preto = 4,\n    //% block=\"▮▮▯\"\n    preto_preto_branco = 5,\n    //% block=\"▮▯▯\"\n    branco_preto_preto = 6,\n    //% block=\"▯▮▯\"\n    preto_branco_preto = 7,\n    //% block=\"▯▯▯\"\n    preto_preto_preto = 8\n}\nconst enum DistanceUnit {\n    //% block=\"cm\"\n    CM = 58, // Duração do eco de ida e volta em microssegundos (uS) para dois centímetros, 343 m/s ao nível do mar e 20°C\n    //% block=\"Polegada\"\n    INCH = 148, // Duração da viagem de ida e volta do eco em microssegundos (uS) para duas polegadas, 343 m/s ao nível do mar e 20°C\n}\n\n//% color=\"#369ddd\"  icon=\"\\uf1b9\" block=\"Seguidor de Linha\"\nnamespace Seguidor_de_Linha {\n    const PCA9685_ADDRESS = 0x40\n    const MODE1 = 0x00\n    const MODE2 = 0x01\n    const SUBADR1 = 0x02\n    const SUBADR2 = 0x03\n    const SUBADR3 = 0x04\n    const PRESCALE = 0xFE\n    const LED0_ON_L = 0x06\n    const LED0_ON_H = 0x07\n    const LED0_OFF_L = 0x08\n    const LED0_OFF_H = 0x09\n    const ALL_LED_ON_L = 0xFA\n    const ALL_LED_ON_H = 0xFB\n    const ALL_LED_OFF_L = 0xFC\n    const ALL_LED_OFF_H = 0xFD\n\n    const STP_CHA_L = 2047\n    const STP_CHA_H = 4095\n\n    const STP_CHB_L = 1\n    const STP_CHB_H = 2047\n\n    const STP_CHC_L = 1023\n    const STP_CHC_H = 3071\n\n    const STP_CHD_L = 3071\n    const STP_CHD_H = 1023\n\n    // HT16K33 commands\n    const HT16K33_ADDRESS = 0x70\n    const HT16K33_BLINK_CMD = 0x80\n    const HT16K33_BLINK_DISPLAYON = 0x01\n    const HT16K33_BLINK_OFF = 0\n    const HT16K33_BLINK_2HZ = 1\n    const HT16K33_BLINK_1HZ = 2\n    const HT16K33_BLINK_HALFHZ = 3\n    const HT16K33_CMD_BRIGHTNESS = 0xE0\n\n    export enum Servos {\n        S1 = 0x01,\n        S2 = 0x02,\n        S3 = 0x03,\n        S4 = 0x04,\n        S5 = 0x05,\n        S6 = 0x06,\n        S7 = 0x07,\n        S8 = 0x08\n    }\n\n    export enum Motors {\n        M1A = 0x1,\n        M1B = 0x2,\n        M2A = 0x3,\n        M2B = 0x4\n    }\n\n    export enum Steppers {\n        M1 = 0x1,\n        M2 = 0x2\n    }\n\n    export enum SonarVersion {\n        V1 = 0x1,\n        V2 = 0x2\n    }\n\n    export enum Turns {\n        //% blockId=\"T1B4\" block=\"1/4\"\n        T1B4 = 90,\n        //% blockId=\"T1B2\" block=\"1/2\"\n        T1B2 = 180,\n        //% blockId=\"T1B0\" block=\"1\"\n        T1B0 = 360,\n        //% blockId=\"T2B0\" block=\"2\"\n        T2B0 = 720,\n        //% blockId=\"T3B0\" block=\"3\"\n        T3B0 = 1080,\n        //% blockId=\"T4B0\" block=\"4\"\n        T4B0 = 1440,\n        //% blockId=\"T5B0\" block=\"5\"\n        T5B0 = 1800\n    }\n\n    export enum ValueUnit {\n        //% block=\"mm\"\n        Millimetros,\n        //% block=\"cm\"\n        Centimetros\n    }\n\n    let initialized = false\n    let initializedMatrix = false\n    let matBuf = pins.createBuffer(17);\n    let distanceBuf = 0;\n\n    function i2cwrite(addr: number, reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2ccmd(addr: number, value: number) {\n        let buf = pins.createBuffer(1)\n        buf[0] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2cread(addr: number, reg: number) {\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\n        return val;\n    }\n\n    function initPCA9685(): void {\n        i2cwrite(PCA9685_ADDRESS, MODE1, 0x00)\n        setFreq(50);\n        for (let idx = 0; idx < 16; idx++) {\n            setPwm(idx, 0, 0);\n        }\n        initialized = true\n    }\n\n    function setFreq(freq: number): void {\n        // Constrain the frequency\n        let prescaleval = 25000000;\n        prescaleval /= 4096;\n        prescaleval /= freq;\n        prescaleval -= 1;\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\n        let oldmode = i2cread(PCA9685_ADDRESS, MODE1);\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\n        i2cwrite(PCA9685_ADDRESS, MODE1, newmode); // go to sleep\n        i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);\n        control.waitMicros(5000);\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);\n    }\n\n    function setPwm(channel: number, on: number, off: number): void {\n        if (channel < 0 || channel > 15)\n            return;\n        //serial.writeValue(\"ch\", channel)\n        //serial.writeValue(\"on\", on)\n        //serial.writeValue(\"off\", off)\n\n        let buf = pins.createBuffer(5);\n        buf[0] = LED0_ON_L + 4 * channel;\n        buf[1] = on & 0xff;\n        buf[2] = (on >> 8) & 0xff;\n        buf[3] = off & 0xff;\n        buf[4] = (off >> 8) & 0xff;\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf);\n    }\n\n\n    function setStepper(index: number, dir: boolean): void {\n        if (index == 1) {\n            if (dir) {\n                setPwm(0, STP_CHA_L, STP_CHA_H);\n                setPwm(2, STP_CHB_L, STP_CHB_H);\n                setPwm(1, STP_CHC_L, STP_CHC_H);\n                setPwm(3, STP_CHD_L, STP_CHD_H);\n            } else {\n                setPwm(3, STP_CHA_L, STP_CHA_H);\n                setPwm(1, STP_CHB_L, STP_CHB_H);\n                setPwm(2, STP_CHC_L, STP_CHC_H);\n                setPwm(0, STP_CHD_L, STP_CHD_H);\n            }\n        } else {\n            if (dir) {\n                setPwm(4, STP_CHA_L, STP_CHA_H);\n                setPwm(6, STP_CHB_L, STP_CHB_H);\n                setPwm(5, STP_CHC_L, STP_CHC_H);\n                setPwm(7, STP_CHD_L, STP_CHD_H);\n            } else {\n                setPwm(7, STP_CHA_L, STP_CHA_H);\n                setPwm(5, STP_CHB_L, STP_CHB_H);\n                setPwm(6, STP_CHC_L, STP_CHC_H);\n                setPwm(4, STP_CHD_L, STP_CHD_H);\n            }\n        }\n    }\n\n    function stopMotor(index: number) {\n        setPwm((index - 1) * 2, 0, 0);\n        setPwm((index - 1) * 2 + 1, 0, 0);\n    }\n\n    function matrixInit() {\n        i2ccmd(HT16K33_ADDRESS, 0x21);// turn on oscillator\n        i2ccmd(HT16K33_ADDRESS, HT16K33_BLINK_CMD | HT16K33_BLINK_DISPLAYON | (0 << 1));\n        i2ccmd(HT16K33_ADDRESS, HT16K33_CMD_BRIGHTNESS | 0xF);\n    }\n\n    function matrixShow() {\n        matBuf[0] = 0x00;\n        pins.i2cWriteBuffer(HT16K33_ADDRESS, matBuf);\n    }\n    /**\n     * Execute one motor at the same time\n     * @param motor First Motor; eg: M1A, M1B, M2A, M2B\n     * @param speed [-255-255] speed of motor; eg: 150, -150\n    */\n\n    //% blockId=robotbit_motor_run block=\"Motor|%index|velocidade %speed\"\n    //% group=\"Motores\" weight=59\n    //% speed.min=-255 speed.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function MotorRun(index: Motors, speed: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        speed = speed * 16; // map 255 to 4096\n        if (speed >= 4096) {\n            speed = 4095\n        }\n        if (speed <= -4096) {\n            speed = -4095\n        }\n        if (index > 4 || index <= 0)\n            return\n        let pp = (index - 1) * 2\n        let pn = (index - 1) * 2 + 1\n        if (speed >= 0) {\n            setPwm(pp, 0, speed)\n            setPwm(pn, 0, 0)\n        } else {\n            setPwm(pp, 0, 0)\n            setPwm(pn, 0, -speed)\n        }\n    }\n\n\n    /**\n     * Execute two motors at the same time\n     * @param motor First Motor; eg: M1A, M1B\n     * @param speed1 [-255-255] speed of motor; eg: 150, -150\n     * @param motor Second Motor; eg: M2A, M2B\n     * @param speed2 [-255-255] speed of motor; eg: 150, -150\n    */\n    //% blockId=robotbit_motor_dual block=\"Motores|%motor1|velocidade %speed1|%motor2|velocidade %speed2\"\n    //% group=\"Motores\" weight=58\n    //% speed1.min=-255 speed1.max=255\n    //% speed2.min=-255 speed2.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function MotorRunDual(motor1: Motors, speed1: number, motor2: Motors, speed2: number): void {\n        MotorRun(motor1, speed1);\n        MotorRun(motor2, speed2);\n    }\n    /**\n    * Execute two motors at the same time\n    * @param motors First Motor; eg: M1A, M1B\n    * @param speed1 [-255-255] speed of motor; eg: 150, -150\n    * @param motors Second Motor; eg: M2A, M2B\n    * @param speed2 [-255-255] speed of motor; eg: 150, -150\n    * @param delay seconde delay to stop; eg: 1\n   */\n    //% blockId=robotbit_motor_dual_DELAY block=\"Motores com delay |%motor1|velocidade %speed1|%motor2|velocidade %speed2 espera(em seg.)  %delay\"\n    //% group=\"Motores\" weight=62\n    //% speed1.min=-255 speed1.max=255\n    //% speed2.min=-255 speed2.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=5\n    export function MotorRunDualDELAY(motor1: Motors, speed1: number, motor2: Motors, speed2: number, delay: number): void {\n        MotorRun(motor1, speed1);\n        MotorRun(motor2, speed2);\n        basic.pause(delay * 1000);\n        MotorRun(motor1, 0);\n        MotorRun(motor2, 0);\n    }\n    /**\n     * Execute motores únicos com atraso\n     * @param index Motor Index; eg: M1A, M1B, M2A, M2B\n     * @param speed [-255-255] speed of motor; eg: 150, -150\n     * @param delay seconde delay to stop; eg: 1\n    */\n    //% blockId=robotbit_motor_rundelay block=\"Motor|%index|velocidade %speed|espera %delay|s\"\n    //% group=\"Motores\" weight=57\n    //% speed.min=-255 speed.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function MotorRunDelay(index: Motors, speed: number, delay: number): void {\n        MotorRun(index, speed);\n        basic.pause(delay * 1000);\n        MotorRun(index, 0);\n    }\n\n\n\n    //% blockId=robotbit_stop block=\"Parar Motor|%index|\"\n    //% group=\"Motores\" weight=56\n    export function MotorStop(index: Motors): void {\n        MotorRun(index, 0);\n    }\n\n    //% blockId=robotbit_stop_all block=\"Parando todos os motores\"\n    //% group=\"Motores\" weight=55\n    //% blockGap=50\n    export function MotorStopAll(): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        for (let idx = 1; idx <= 4; idx++) {\n            stopMotor(idx);\n        }\n    }\n\n    const MICROBIT_LABCODE_ULTRASONIC_OBJECT_DETECTED_ID = 798;\n    const MAX_ULTRASONIC_TRAVEL_TIME = 300 * DistanceUnit.CM;\n    const ULTRASONIC_MEASUREMENTS = 3;\n\n    interface UltrasonicRoundTrip {\n        ts: number;\n        rtt: number;\n    }\n\n    interface UltrasonicDevice {\n        trig: DigitalPin | undefined;\n        roundTrips: UltrasonicRoundTrip[];\n        medianRoundTrip: number;\n        travelTimeObservers: number[];\n    }\n\n    let ultrasonicState: UltrasonicDevice;\n\n\n\n    /**\n        * Acquiring ultrasonic data\n        * @param trig trig pin selection enumeration, eg:DigitalPin.P12\n        * @param echo echo pin selection enumeration, eg:DigitalPin.P13\n        * @param unit unit of distance, eg: DistanceUnit.CM\n        */\n    //% group=\"Ultrassônico versão compacta\"\n    //% blockId=\"labcode_ultrasonico_conectado\"\n    //% block=\"Sensor Ultrassônico pino TRIG %trig pino ECHO %echo %unit\"\n    //% weight=94\n    export function readUltrassonic(trig: DigitalPin, echo: DigitalPin): number {\n        let data;\n        pins.digitalWritePin(trig, 1);\n        basic.pause(1);\n        pins.digitalWritePin(trig, 0)\n        if (pins.digitalReadPin(echo) == 0) {\n            pins.digitalWritePin(trig, 0);\n            pins.digitalWritePin(trig, 1);\n            basic.pause(20);\n            pins.digitalWritePin(trig, 0);\n            data = pins.pulseIn(echo, PulseValue.High, 500 * 58);\n        } else {\n            pins.digitalWritePin(trig, 1);\n            pins.digitalWritePin(trig, 0);\n            basic.pause(20);\n            pins.digitalWritePin(trig, 0);\n            data = pins.pulseIn(echo, PulseValue.High, 500 * 58)\n        }\n        data = data / 59;\n        if (data <= 0)\n            return 0;\n        if (data > 500)\n            return 500;\n        return Math.round(data);\n    }\n\n\n\n\n\n    /**\n     * Configures the ultrasonic distance sensor and measures continuously in the background.\n     * @param trig pin connected to trig, eg: DigitalPin.P12\n     * @param echo pin connected to echo, eg: DigitalPin.P13\n     */\n    //% group=\"Ultrassônico\"\n    //% blockId=\"labcode_ultrasonico_connectado\"\n    //% block=\"Sensor de distancia ultrassônica | Trig em %trig | e Echo em %echo\"\n    //% trig.fieldEditor=\"gridpicker\"\n    //% trig.fieldOptions.columns=4\n    //% trig.fieldOptions.tooltips=\"false\"\n    //% echo.fieldEditor=\"gridpicker\"\n    //% echo.fieldOptions.columns=4\n    //% echo.fieldOptions.tooltips=\"false\"\n    //% weight=80\n    export function connectUltrasonicDistanceSensor(\n        trig: DigitalPin,\n        echo: DigitalPin\n    ): void {\n        if (ultrasonicState && ultrasonicState.trig) {\n            return;\n        }\n\n        if (!ultrasonicState) {\n            ultrasonicState = {\n                trig: trig,\n                roundTrips: [{ ts: 0, rtt: MAX_ULTRASONIC_TRAVEL_TIME }],\n                medianRoundTrip: MAX_ULTRASONIC_TRAVEL_TIME,\n                travelTimeObservers: [],\n            };\n        } else {\n            ultrasonicState.trig = trig;\n        }\n\n        pins.onPulsed(echo, PulseValue.High, () => {\n            if (\n                pins.pulseDuration() < MAX_ULTRASONIC_TRAVEL_TIME &&\n                ultrasonicState.roundTrips.length <= ULTRASONIC_MEASUREMENTS\n            ) {\n                ultrasonicState.roundTrips.push({\n                    ts: input.runningTime(),\n                    rtt: pins.pulseDuration(),\n                });\n            }\n        });\n\n        control.inBackground(measureInBackground);\n    }\n\n    /**\n     * Faça algo quando um objeto for detectado pela primeira vez dentro de um intervalo especificado.\n     * @param distance distance to object, eg: 20\n     * @param unit unit of distance, eg: DistanceUnit.CM\n     * @param handler body code to run when the event is raised\n     */\n    //% group=\"Ultrassônico\"\n    //% blockId=labcode_ultrasonic_on_object_detected\n    //% block=\"Objeto detectado a | %distance | %unit\"\n    //% weight=69\n    export function onUltrasonicObjectDetected(\n        distance: number,\n        unit: DistanceUnit,\n        handler: () => void\n    ) {\n        if (distance <= 0) {\n            return;\n        }\n\n        if (!ultrasonicState) {\n            ultrasonicState = {\n                trig: undefined,\n                roundTrips: [{ ts: 0, rtt: MAX_ULTRASONIC_TRAVEL_TIME }],\n                medianRoundTrip: MAX_ULTRASONIC_TRAVEL_TIME,\n                travelTimeObservers: [],\n            };\n        }\n\n        const travelTimeThreshold = Math.imul(distance, unit);\n\n        ultrasonicState.travelTimeObservers.push(travelTimeThreshold);\n\n        control.onEvent(\n            MICROBIT_LABCODE_ULTRASONIC_OBJECT_DETECTED_ID,\n            travelTimeThreshold,\n            () => {\n                handler();\n            }\n        );\n    }\n\n    /**\n     * Retorna a distância até um objeto no intervalo de 1 a 300 centímetros ou até 118 polegadas.\n     * O valor máximo é retornado para indicar quando nenhum objeto foi detectado.\n     * -1 é retornado quando o dispositivo não está conectado.\n     * @param unit unit of distance, eg: DistanceUnit.CM\n     */\n    //% group=\"Ultrassônico\"\n    //% blockId=\"labcode_ultrasonic_distance\"\n    //% block=\"A distância é %unit\"\n    //% weight=60\n    export function getUltrasonicDistance(unit: DistanceUnit): number {\n        if (!ultrasonicState) {\n            return -1;\n        }\n        basic.pause(0); // yield to allow background processing when called in a tight loop\n        return Math.idiv(ultrasonicState.medianRoundTrip, unit);\n    }\n\n\n    /**\n     * Returns `true` if an object is within the specified distance. `false` otherwise\n     * @param distance distance to object, eg: 20\n     * @param unit unit of distance, eg: DistanceUnit.CM\n     */\n    //% group=\"Ultrassônico\"\n    //% blockId=\"labcode_ultrasonic_less_than\"\n    //% block=\"A distância é menor que | %distance | %unit\"\n    //% weight=50\n    export function isUltrasonicDistanceLessThan(\n        distance: number,\n        unit: DistanceUnit\n    ): boolean {\n        if (!ultrasonicState) {\n            return false;\n        }\n        basic.pause(0); // rendimento para permitir o processamento em segundo plano quando chamado em um loop apertado\n        return Math.idiv(ultrasonicState.medianRoundTrip, unit) < distance;\n    }\n\n    function triggerPulse() {\n        // Reseta o pino trigger\n        pins.setPull(ultrasonicState.trig, PinPullMode.PullNone);\n        pins.digitalWritePin(ultrasonicState.trig, 0);\n        control.waitMicros(2);\n\n        // Trigger pulso\n        pins.digitalWritePin(ultrasonicState.trig, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(ultrasonicState.trig, 0);\n    }\n\n    function getMedianRRT(roundTrips: UltrasonicRoundTrip[]) {\n        const roundTripTimes = roundTrips.map((urt) => urt.rtt);\n        return median(roundTripTimes);\n    }\n\n    // Retorna o valor mediano da entrada não vazia\n    function median(values: number[]) {\n        values.sort((a, b) => {\n            return a - b;\n        });\n        return values[(values.length - 1) >> 1];\n    }\n\n    function measureInBackground() {\n        const trips = ultrasonicState.roundTrips;\n        const TIME_BETWEEN_PULSE_MS = 145;\n\n        while (true) {\n            const now = input.runningTime();\n\n            if (trips[trips.length - 1].ts < now - TIME_BETWEEN_PULSE_MS - 10) {\n                ultrasonicState.roundTrips.push({\n                    ts: now,\n                    rtt: MAX_ULTRASONIC_TRAVEL_TIME,\n                });\n            }\n\n            while (trips.length > ULTRASONIC_MEASUREMENTS) {\n                trips.shift();\n            }\n\n            ultrasonicState.medianRoundTrip = getMedianRRT(\n                ultrasonicState.roundTrips\n            );\n\n            for (let i = 0; i < ultrasonicState.travelTimeObservers.length; i++) {\n                const threshold = ultrasonicState.travelTimeObservers[i];\n                if (threshold > 0 && ultrasonicState.medianRoundTrip <= threshold) {\n                    control.raiseEvent(\n                        MICROBIT_LABCODE_ULTRASONIC_OBJECT_DETECTED_ID,\n                        threshold\n                    );\n                    // use sinal negativo para indicar que notificamos o evento\n                    ultrasonicState.travelTimeObservers[i] = -threshold;\n                } else if (\n                    threshold < 0 &&\n                    ultrasonicState.medianRoundTrip > -threshold\n                ) {\n                    // o objeto está fora do limite de detecção -> reativar o observador\n                    ultrasonicState.travelTimeObservers[i] = -threshold;\n                }\n            }\n\n            triggerPulse();\n            basic.pause(TIME_BETWEEN_PULSE_MS);\n        }\n    }\n    /**\n         * Leitura do sensor de linha [0-1]\n        */\n    //% block=\"sensor Digital de Linha |%Sensor| pino |%pin|\"\n    //% group=\"Sensores de linha\"\n    export function detectline(sensor: Sensor, pin: DigitalPin): number {\n        if (sensor == Sensor.Esquerdo) {\n            return pins.digitalReadPin(pin);\n        } else if (sensor == Sensor.Centro) {\n            return pins.digitalReadPin(pin)\n        }\n        else if (sensor == Sensor.Direito) {\n            return pins.digitalReadPin(pin)\n        } else {\n            return -1\n        }\n\n\n    }\n    /**\n         * Leitura do sensor de linha [0-1023]\n         * @param pin [0-1023] pin; eg: 600\n        */\n    //% block=\"Sensor Analógico de Linha |%Sensor| pino |%pin|\"\n    //% group=\"Sensores de linha\"\n    export function detecetlinha(sensor: Sensor, pin: AnalogPin): number {\n        if (sensor == Sensor.Esquerdo) {\n            return pins.analogReadPin(pin);\n        } else if (sensor == Sensor.Centro) {\n            return pins.analogReadPin(pin);\n        }\n        else if (sensor == Sensor.Direito) {\n            return pins.analogReadPin(pin);\n        } else {\n            return -1\n        }\n    }\n\n    /**\n         * Leitura do sensor de linha [0-1]\n     */\n    //% blockId=\"umsensor\" block=\"Detecção do sensor de linha Digital (p1) %Umsensor\"\n    //% group=\"Sensores de linha V.2( pinos: P0,  P1 e ou  P2 Cores: Branco: ▮ e Preto: ▯)\"\n    export function readUm(um: Um_sensor): boolean {\n\n        // let p1 = pins.digitalReadPin(DigitalPin.P1);\n\n        if (um == Um_sensor.branco) {\n            if (pins.digitalReadPin(DigitalPin.P1) == 0) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (um == Um_sensor.preto) {\n            if (pins.digitalReadPin(DigitalPin.P1) == 1) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n    /**\n       * Leitura do sensor de linha [0-1]\n      */\n    //% blockId=\"doissensores\" block=\"Detecção dos sensores(P1 e P2) de linha Digital %Doissensores\"\n    //% group=\"Sensores de linha V.2( pinos: P0,  P1 e ou  P2 Cores: Branco: ▮ e Preto: ▯)\"\n    export function readDois(dois: Dois_sensores): boolean {\n\n        // let p1 = pins.digitalReadPin(DigitalPin.P1);\n        // let p2 = pins.digitalReadPin(DigitalPin.P2);\n\n        if (dois == Dois_sensores.branco_branco) {\n            if (pins.digitalReadPin(DigitalPin.P1) == 0 && pins.digitalReadPin(DigitalPin.P2) == 0) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (dois == Dois_sensores.branco_preto) {\n            if (pins.digitalReadPin(DigitalPin.P1) == 0 && pins.digitalReadPin(DigitalPin.P2) == 1) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (dois == Dois_sensores.preto_branco) {\n            if (pins.digitalReadPin(DigitalPin.P1) == 1 && pins.digitalReadPin(DigitalPin.P2) == 0) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (dois == Dois_sensores.preto_preto) {\n            if (pins.digitalReadPin(DigitalPin.P1) == 1 && pins.digitalReadPin(DigitalPin.P2) == 1) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n    /**\n         * Leitura do sensor de linha [0-1]\n        */\n    //% blockId=\"tresssensores\" block=\"Detecção dos sensores de linha Digital %Tressensores\"\n    //% group=\"Sensores de linha V.2( pinos: P0,  P1 e ou  P2 Cores: Branco: ▮ e Preto: ▯)\"\n    export function readtres(tres: Tres_sensores): boolean {\n\n        // let p1 = pins.digitalReadPin(DigitalPin.P0);\n        // let p2 = pins.digitalReadPin(DigitalPin.P1);\n        // let p3 = pins.digitalReadPin(DigitalPin.P2);\n        if (tres == Tres_sensores.branco_branco_branco) {\n            if (pins.digitalReadPin(DigitalPin.P0) == 0 && pins.digitalReadPin(DigitalPin.P1) == 0 && pins.digitalReadPin(DigitalPin.P2) == 0) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tres == Tres_sensores.branco_branco_preto) {\n            if (pins.digitalReadPin(DigitalPin.P0) == 0 && pins.digitalReadPin(DigitalPin.P1) == 0 && pins.digitalReadPin(DigitalPin.P2) == 1) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tres == Tres_sensores.branco_preto_branco) {\n            if (pins.digitalReadPin(DigitalPin.P0) == 0 && pins.digitalReadPin(DigitalPin.P1) == 1 && pins.digitalReadPin(DigitalPin.P2) == 0) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tres == Tres_sensores.preto_branco_branco) {\n            if (pins.digitalReadPin(DigitalPin.P0) == 1 && pins.digitalReadPin(DigitalPin.P1) == 0 && pins.digitalReadPin(DigitalPin.P2) == 0) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tres == Tres_sensores.preto_preto_branco) {\n            if (pins.digitalReadPin(DigitalPin.P0) == 1 && pins.digitalReadPin(DigitalPin.P1) == 1 && pins.digitalReadPin(DigitalPin.P2) == 0) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tres == Tres_sensores.branco_preto_preto) {\n            if (pins.digitalReadPin(DigitalPin.P0) == 0 && pins.digitalReadPin(DigitalPin.P1) == 1 && pins.digitalReadPin(DigitalPin.P2) == 1) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tres == Tres_sensores.preto_branco_preto) {\n            if (pins.digitalReadPin(DigitalPin.P0) == 1 && pins.digitalReadPin(DigitalPin.P1) == 0 && pins.digitalReadPin(DigitalPin.P2) == 1) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tres == Tres_sensores.preto_preto_preto) {\n            if (pins.digitalReadPin(DigitalPin.P0) == 1 && pins.digitalReadPin(DigitalPin.P1) == 1 && pins.digitalReadPin(DigitalPin.P2) == 1) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n    /**\n             * Leitura do sensor de linha [0-1023]\n          * @param m [0-1023] m; eg: 600\n    */\n    //% blockId=\"umasensor\" block=\"Detecção do sensor de linha Analógica (P1) %Umsensor | Média = %m\"\n    //% group=\"Sensores de linha V.2( pinos: P0,  P1 e ou  P2 Cores: Branco: ▮ e Preto: ▯)\"\n    //% m.min=0 m.max=1023\n    export function readUma(uma: Um_sensor, m: number): boolean {\n\n        // let p1 = pins.analogReadPin(AnalogPin.P1);\n\n        if (uma == Um_sensor.branco) {\n            if (pins.analogReadPin(AnalogPin.P1) < m) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (uma == Um_sensor.preto) {\n            if (pins.analogReadPin(AnalogPin.P1) > m) {\n                return true;\n            } else {\n                return false;\n            }\n\n        } else {\n            return true;\n        }\n    }\n    /**\n         * Leitura do sensor de linha [0-1023]\n         * @param m [0-1023] m; eg: 600\n     */\n    //% blockId=\"doissensoresa\" block=\"Detecção dos sensores(P1 e P2) de linha Analógica %Doissensores | Média = %m\"\n    //% group=\"Sensores de linha V.2( pinos: P0,  P1 e ou  P2 Cores: Branco: ▮ e Preto: ▯)\"\n    //% m.min=0 m.max=1023\n    export function readDoisa(doisa: Dois_sensores, m: number): boolean {\n\n        // let p1 = pins.analogReadPin(AnalogPin.P1);\n        // let p2 = pins.analogReadPin(AnalogPin.P2);\n\n        if (doisa == Dois_sensores.branco_branco) {\n            if (pins.analogReadPin(AnalogPin.P1) < m && pins.analogReadPin(AnalogPin.P2) < m) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (doisa == Dois_sensores.branco_preto) {\n            if (pins.analogReadPin(AnalogPin.P1) < m && pins.analogReadPin(AnalogPin.P2) > m) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (doisa == Dois_sensores.preto_branco) {\n            if (pins.analogReadPin(AnalogPin.P1) > m && pins.analogReadPin(AnalogPin.P2) < m) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (doisa == Dois_sensores.preto_preto) {\n            if (pins.analogReadPin(AnalogPin.P1) > m && pins.analogReadPin(AnalogPin.P2) > m) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n    /**\n             * Leitura do sensor de linha [0-1023]\n         * @param m [0-1023] m; eg: 600\n            */\n    //% blockId=\"tresssensoresa\" block=\"Detecção dos sensores de linha Analógica %Tressensores| Média = %m\"\n    //% group=\"Sensores de linha V.2( pinos: P0,  P1 e ou  P2 Cores: Branco: ▮ e Preto: ▯)\"\n    //% m.min=0 m.max=1023\n    export function readtresa(tresa: Tres_sensores, m: number): boolean {\n\n        // let p1 = pins.analogReadPin(AnalogPin.P0);\n        // let p2 = pins.analogReadPin(AnalogPin.P1);\n        // let p3 = pins.analogReadPin(AnalogPin.P2);\n        if (tresa == Tres_sensores.branco_branco_branco) {\n            if (pins.analogReadPin(AnalogPin.P0) < m && (pins.analogReadPin(AnalogPin.P1) < m && pins.analogReadPin(AnalogPin.P2) < m)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tresa == Tres_sensores.branco_branco_preto) {\n            if (pins.analogReadPin(AnalogPin.P0) < m && (pins.analogReadPin(AnalogPin.P1) < m && pins.analogReadPin(AnalogPin.P2) > m)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tresa == Tres_sensores.branco_preto_branco) {\n            if (pins.analogReadPin(AnalogPin.P0) < m && (pins.analogReadPin(AnalogPin.P1) > m && pins.analogReadPin(AnalogPin.P2) < m)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tresa == Tres_sensores.preto_branco_branco) {\n            if (pins.analogReadPin(AnalogPin.P0) > m && (pins.analogReadPin(AnalogPin.P1) < m && pins.analogReadPin(AnalogPin.P2) < m)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tresa == Tres_sensores.preto_preto_branco) {\n            if (pins.analogReadPin(AnalogPin.P0) > m && (pins.analogReadPin(AnalogPin.P1) > m && pins.analogReadPin(AnalogPin.P2) < m)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tresa == Tres_sensores.branco_preto_preto) {\n            if (pins.analogReadPin(AnalogPin.P0) < m && (pins.analogReadPin(AnalogPin.P1) > m && pins.analogReadPin(AnalogPin.P2) > m)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tresa == Tres_sensores.preto_branco_preto) {\n            if (pins.analogReadPin(AnalogPin.P0) > m && (pins.analogReadPin(AnalogPin.P1) < m && pins.analogReadPin(AnalogPin.P2) > m)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tresa == Tres_sensores.preto_preto_preto) {\n            if (pins.analogReadPin(AnalogPin.P0) > m && (pins.analogReadPin(AnalogPin.P1) > m && pins.analogReadPin(AnalogPin.P2) > m)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n    //% subcategory=\"Extra\"\n    /**\n          * Leitura do sensor de linha [0-1023]\n         * @param m1 [0-1023] m1; eg: 600\n         * @param m2 [0-1023] m2; eg: 600\n      */\n    //% blockId=\"doissensoresam\" block=\"Detecção dos sensores(P1 e P2) de linha Analógica %Doissensores | Média 1 = %m1| Média 2 = %m2\"\n    //% group=\"Sensores de linha V.2( pinos: P0,  P1 e ou  P2 Cores: Branco: ▮ e Preto: ▯)\"\n    //% m1.min=0 m1.max=1023\n    //% m2.min=0 m2.max=1023\n    export function readDoisam(doisa: Dois_sensores, m1: number, m2: number): boolean {\n\n        // let p1 = pins.analogReadPin(AnalogPin.P1);\n        // let p2 = pins.analogReadPin(AnalogPin.P2);\n\n        if (doisa == Dois_sensores.branco_branco) {\n            if (pins.analogReadPin(AnalogPin.P1) < m1 && pins.analogReadPin(AnalogPin.P2) < m2) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (doisa == Dois_sensores.branco_preto) {\n            if (pins.analogReadPin(AnalogPin.P1) < m1 && pins.analogReadPin(AnalogPin.P2) > m2) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (doisa == Dois_sensores.preto_branco) {\n            if (pins.analogReadPin(AnalogPin.P1) > m1 && pins.analogReadPin(AnalogPin.P2) < m2) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (doisa == Dois_sensores.preto_preto) {\n            if (pins.analogReadPin(AnalogPin.P1) > m1 && pins.analogReadPin(AnalogPin.P2) > m2) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n    //% subcategory=\"Extra\"\n    /**\n             * Leitura do sensor de linha [0-1023]\n         * @param m1 [0-1023] m1; eg: 600\n         * @param m2 [0-1023] m2; eg: 600\n         * @param m3 [0-1023] m3; eg: 600\n            */\n    //% blockId=\"tresssensoresam\" block=\"Detecção de linha Analógica %Tressensores| Média 1 = %m1 Média 2 = %m2 Média 3 = %m3\"\n    //% group=\"Sensores de linha V.2( pinos: P0,  P1 e ou  P2 Cores: Branco: ▮ e Preto: ▯)\"\n    //% m1.min=0 m1.max=1023\n    //% m2.min=0 m2.max=1023\n    //% m3.min=0 m3.max=1023\n    export function readtresam(tresa: Tres_sensores, m1: number, m2: number, m3: number): boolean {\n\n        // let p1 = pins.analogReadPin(AnalogPin.P0);\n        // let p2 = pins.analogReadPin(AnalogPin.P1);\n        // let p3 = pins.analogReadPin(AnalogPin.P2);\n        if (tresa == Tres_sensores.branco_branco_branco) {\n            if (pins.analogReadPin(AnalogPin.P0) < m1 && (pins.analogReadPin(AnalogPin.P1) < m2 && pins.analogReadPin(AnalogPin.P2) < m3)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tresa == Tres_sensores.branco_branco_preto) {\n            if (pins.analogReadPin(AnalogPin.P0) < m1 && (pins.analogReadPin(AnalogPin.P1) < m2 && pins.analogReadPin(AnalogPin.P2) > m3)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tresa == Tres_sensores.branco_preto_branco) {\n            if (pins.analogReadPin(AnalogPin.P0) < m1 && (pins.analogReadPin(AnalogPin.P1) > m2 && pins.analogReadPin(AnalogPin.P2) < m3)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tresa == Tres_sensores.preto_branco_branco) {\n            if (pins.analogReadPin(AnalogPin.P0) > m1 && (pins.analogReadPin(AnalogPin.P1) < m2 && pins.analogReadPin(AnalogPin.P2) < m3)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tresa == Tres_sensores.preto_preto_branco) {\n            if (pins.analogReadPin(AnalogPin.P0) > m1 && (pins.analogReadPin(AnalogPin.P1) > m2 && pins.analogReadPin(AnalogPin.P2) < m3)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tresa == Tres_sensores.branco_preto_preto) {\n            if (pins.analogReadPin(AnalogPin.P0) < m1 && (pins.analogReadPin(AnalogPin.P1) > m2 && pins.analogReadPin(AnalogPin.P2) > m3)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tresa == Tres_sensores.preto_branco_preto) {\n            if (pins.analogReadPin(AnalogPin.P0) > m1 && (pins.analogReadPin(AnalogPin.P1) < m2 && pins.analogReadPin(AnalogPin.P2) > m3)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else if (tresa == Tres_sensores.preto_preto_preto) {\n            if (pins.analogReadPin(AnalogPin.P0) > m1 && (pins.analogReadPin(AnalogPin.P1) > m2 && pins.analogReadPin(AnalogPin.P2) > m3)) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n    //% subcategory=\"LEDS\" icon=\"\\uf1b9\"\n    /*\n    /**\n            * Acionamento do Led [1-0]\n           */\n    //% block=\"LED |%Sensor|  |%pins|  |%Leds|\"\n    //% group=\"Led\"\n    export function led(sensor: Sensor, pin: DigitalPin, led: Leds): boolean {\n        if (led == Leds.ON) {\n            pins.digitalWritePin(pin, 1);\n            return true;\n        } else if (led == Leds.OFF) {\n            pins.digitalWritePin(pin, 0);\n            return true;\n        }\n        else {\n            return true;\n        }\n\n\n    }\n    //% subcategory=\"LEDS\" icon=\"\\uf1b9\"\n    /*\n    /**\n      * @param led led pin selection enumeration, eg:DigitalPin.P12\n            * Acionamento do Led [1-0]\n           */\n    //% block=\"LED |%Sensor|  |%pins|  |%Leds|\"\n    //% group=\"Led\"\n    //% weight=80\n    export function led1(sensor: Sensor, pin: DigitalPin, led: Leds): void {\n        if (led == Leds.ON) {\n            return pins.digitalWritePin(pin, 1);\n        } else if (led == Leds.OFF) {\n            return pins.digitalWritePin(pin, 0);\n        }\n\n    }\n    //% subcategory=\"LEDS\" icon=\"\\uf1b9\"\n    /*\n    /**\n      * @param led led pin selection enumeration, eg:DigitalPin.P1\n      * @param delay seconde delay to stop; eg: 1\n            * Acionamento do Led [1-0]\n           */\n    //% block=\"PISCA LED |%Sensor|  |%pins|  espera %delay|seg.\"\n    //% group=\"Led\"\n    //% weight=80\n    export function piscaled(sensor: Sensor, pin: DigitalPin, delay: number): void {\n        pins.digitalWritePin(pin, 1);\n        basic.pause(delay * 1000);\n        pins.digitalWritePin(pin, 0);\n        basic.pause(delay * 1000);\n\n    }\n}\n"],[0,"\n"]],"start1":0,"start2":0,"length1":37805,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"   \""],[-1,"testFiles\": [\n        \"test.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":231,"start2":231,"length1":76,"length2":31}]},{"type":"added","filename":"test.ts","value":"// testes vão aqui; isto não será compilado quando este pacote for usado como uma extensão.\n"}]}],"snapshots":[{"timestamp":1737228418311,"editorVersion":"7.0.40","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"caminho\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1737228521891}